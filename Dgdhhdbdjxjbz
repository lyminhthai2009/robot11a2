// --- Phần định nghĩa và hàm của bạn được giữ nguyên ---

// #include <Wire.h>
// #include "Adafruit_TCS34725.h"

//Adafruit_TCS34725 tcs = Adafruit_TCS34725(TCS34725_INTEGRATIONTIME_50MS, TCS34725_GAIN_4X);

#define PWM_PIN_L_A 2
#define PWM_PIN_L_B 10
#define PWM_PIN_R_A 6
#define PWM_PIN_R_B 5

#define SENSOR_1_PIN 0 // A0
#define SENSOR_2_PIN 1 // A1
#define SENSOR_3_PIN 2 // A2
#define SENSOR_4_PIN 3 // A3

#define W_LED_ON 20
#define IR_LED_ON 21

#define threshold 2000 // Giữ nguyên ngưỡng của bạn

// Tốc độ cơ bản của robot. PID sẽ điều chỉnh dựa trên tốc độ này.
int maxSpeed = 160;

// ==========================================================
// THAM SỐ PID - BẠN SẼ CẦN TINH CHỈNH CÁC GIÁ TRỊ NÀY!
// ==========================================================
// Kp: Hệ số cho thành phần Proportional. QUAN TRỌNG NHẤT.
// Bắt đầu bằng cách tăng Kp từ từ cho đến khi robot bắt đầu dao động quanh vạch đen.
double Kp = 30; // Thử bắt đầu với giá trị này

// Kd: Hệ số cho thành phần Derivative. Giúp giảm dao động.
// Sau khi có Kp, bắt đầu tăng Kd để robot chạy mượt hơn, bớt "lắc".
double Kd = 20; // Thử bắt đầu với giá trị này

// Ki: Hệ số cho thành phần Integral. Giúp khử lỗi tĩnh.
// Thường ít cần thiết hơn, có thể để bằng 0 lúc đầu.
double Ki = 0;

// Các biến cho thuật toán PID
int error = 0;
int lastError = 0;
long integral = 0;
// ==========================================================

void setup() {
  Serial.begin(115200);

  pinMode(PWM_PIN_L_A, OUTPUT);
  pinMode(PWM_PIN_L_B, OUTPUT);
  pinMode(PWM_PIN_R_A, OUTPUT);
  pinMode(PWM_PIN_R_B, OUTPUT);

  pinMode(W_LED_ON, OUTPUT);
  pinMode(IR_LED_ON, OUTPUT);
  digitalWrite(W_LED_ON, 0);
  digitalWrite(IR_LED_ON, 1);
  
  Serial.println("Robot PID Line Follower - Ready!");
}

// Hàm mới để điều khiển động cơ linh hoạt hơn
void setMotorSpeeds(int leftSpeed, int rightSpeed) {
  // Ràng buộc tốc độ trong khoảng -255 đến 255
  leftSpeed = constrain(leftSpeed, -255, 255);
  rightSpeed = constrain(rightSpeed, -255, 255);
  
  // Điều khiển động cơ trái
  if (leftSpeed >= 0) {
    analogWrite(PWM_PIN_L_A, leftSpeed);
    analogWrite(PWM_PIN_L_B, 0);
  } else {
    analogWrite(PWM_PIN_L_A, 0);
    analogWrite(PWM_PIN_L_B, -leftSpeed);
  }
  
  // Điều khiển động cơ phải
  // Lưu ý: Có thể bạn cần nhân rightSpeed với 1 hệ số nhỏ
  // nếu động cơ bên phải của bạn chạy nhanh/chậm hơn bên trái.
  // Ví dụ: rightSpeed *= 1.1;
  if (rightSpeed >= 0) {
    analogWrite(PWM_PIN_R_A, rightSpeed);
    analogWrite(PWM_PIN_R_B, 0);
  } else {
    analogWrite(PWM_PIN_R_A, 0);
    analogWrite(PWM_PIN_R_B, -rightSpeed);
  }
}

void loop() {
  // Đọc giá trị 4 cảm biến
  int s1 = analogRead(SENSOR_1_PIN);
  int s2 = analogRead(SENSOR_2_PIN);
  int s3 = analogRead(SENSOR_3_PIN);
  int s4 = analogRead(SENSOR_4_PIN);

  // Chuyển giá trị analog thành trạng thái nhị phân (0 hoặc 1)
  // 1 = Thấy vạch đen, 0 = Nền trắng
  // Logic này dựa trên code gốc của bạn: (sensor_state <= threshold)
  bool b1 = (s1 <= threshold);
  bool b2 = (s2 <= threshold);
  bool b3 = (s3 <= threshold);
  bool b4 = (s4 <= threshold);

  // --- TÍNH TOÁN "LỖI" (ERROR) ---
  // Gán trọng số cho các cảm biến để xác định vị trí của vạch đen
  // Cảm biến bên trái có trọng số âm, bên phải có trọng số dương.
  // Ví dụ: -3, -1, 1, 3
  error = (b1 * -3) + (b2 * -1) + (b3 * 1) + (b4 * 3);
  
  // Xử lý trường hợp đặc biệt: Mất line (0000)
  // Nếu không thấy line, ta giả sử robot vẫn đang ở vị trí lỗi cuối cùng
  if (!b1 && !b2 && !b3 && !b4) {
    if (lastError > 0) { // Lần cuối thấy line ở bên phải
      error = 5; // Gán lỗi lớn để robot rẽ gắt sang trái tìm line
    } else { // Lần cuối thấy line ở bên trái
      error = -5; // Gán lỗi lớn để robot rẽ gắt sang phải tìm line
    }
  }

  // --- TÍNH TOÁN PID ---
  long proportional = error;
  integral += error;
  long derivative = error - lastError;

  // Giá trị điều chỉnh cuối cùng
  int correction = (Kp * proportional) + (Ki * integral) + (Kd * derivative);

  // Cập nhật lỗi cuối cùng cho vòng lặp tiếp theo
  lastError = error;

  // --- TÍNH TOÁN TỐC ĐỘ ĐỘNG CƠ ---
  int leftSpeed = maxSpeed - correction;
  int rightSpeed = maxSpeed + correction;

  // Gửi tốc độ đến động cơ
  setMotorSpeeds(leftSpeed, rightSpeed);

  // In ra để debug và tinh chỉnh Kp, Ki, Kd
  Serial.print("Error: "); Serial.print(error);
  Serial.print("\t Correction: "); Serial.print(correction);
  Serial.print("\t L_Speed: "); Serial.print(leftSpeed);
  Serial.print("\t R_Speed: "); Serial.println(rightSpeed);
  
  delay(10);
}
