// --- Phần định nghĩa và hàm của bạn được giữ nguyên ---

#define PWM_PIN_L_A 2
#define PWM_PIN_L_B 10
#define PWM_PIN_R_A 6
#define PWM_PIN_R_B 5

#define SENSOR_1_PIN 0
#define SENSOR_2_PIN 1
#define SENSOR_3_PIN 2
#define SENSOR_4_PIN 3

#define W_LED_ON 20
#define IR_LED_ON 21

#define threshold 2000

// Tốc độ cơ bản của robot.
int maxSpeed = 140; // Giữ lại tốc độ gốc của bạn
int minSpeed = 0;   // Tốc độ tối thiểu

// ==========================================================
// THAM SỐ PID - BẮT ĐẦU LẠI TỪ ĐÂY
// ==========================================================
double Kp = 15; // Giảm Kp xuống để bắt đầu lại
double Kd = 10;
double Ki = 0.0;

// Các biến cho thuật toán PID
int error = 0;
int lastError = 0;
// integral không cần thiết lắm lúc đầu
// double integral = 0;
// ==========================================================


void setup() {
  Serial.begin(115200);

  pinMode(PWM_PIN_L_A, OUTPUT);
  pinMode(PWM_PIN_L_B, OUTPUT);
  pinMode(PWM_PIN_R_A, OUTPUT);
  pinMode(PWM_PIN_R_B, OUTPUT);

  pinMode(W_LED_ON, OUTPUT);
  pinMode(IR_LED_ON, OUTPUT);
  digitalWrite(W_LED_ON, 0);
  digitalWrite(IR_LED_ON, 1);
  
  Serial.println("Robot PID Line Follower - V2 - Ready!");
}

// Hàm mới để điều khiển động cơ linh hoạt hơn
void setMotorSpeeds(int leftSpeed, int rightSpeed) {
  // Ràng buộc tốc độ trong khoảng từ -maxSpeed đến maxSpeed
  leftSpeed = constrain(leftSpeed, -maxSpeed, maxSpeed);
  rightSpeed = constrain(rightSpeed, -maxSpeed, maxSpeed);
  
  // Điều khiển động cơ trái
  if (leftSpeed >= 0) {
    analogWrite(PWM_PIN_L_A, leftSpeed);
    analogWrite(PWM_PIN_L_B, 0);
  } else {
    analogWrite(PWM_PIN_L_A, 0);
    analogWrite(PWM_PIN_L_B, -leftSpeed);
  }
  
  // Điều khiển động cơ phải (Áp dụng hệ số bù trừ từ code gốc)
  float right_motor_correction = 1.6; // Lấy từ vspeed_r = vspeed * 1.6 của bạn
  int correctedRightSpeed = rightSpeed * right_motor_correction;
  correctedRightSpeed = constrain(correctedRightSpeed, -255, 255); // Ràng buộc lại sau khi nhân

  if (correctedRightSpeed >= 0) {
    analogWrite(PWM_PIN_R_A, correctedRightSpeed);
    analogWrite(PWM_PIN_R_B, 0);
  } else {
    analogWrite(PWM_PIN_R_A, 0);
    analogWrite(PWM_PIN_R_B, -correctedRightSpeed);
  }
}

void loop() {
  // Đọc giá trị 4 cảm biến
  int s1 = analogRead(SENSOR_1_PIN);
  int s2 = analogRead(SENSOR_2_PIN);
  int s3 = analogRead(SENSOR_3_PIN);
  int s4 = analogRead(SENSOR_4_PIN);

  // Chuyển giá trị analog thành trạng thái nhị phân (0 hoặc 1)
  // 1 = Thấy vạch đen, 0 = Nền trắng
  // Giữ nguyên logic gốc của bạn: (sensor_state <= threshold)
  bool b1 = (s1 <= threshold);
  bool b2 = (s2 <= threshold);
  bool b3 = (s3 <= threshold);
  bool b4 = (s4 <= threshold);

  // --- TÍNH TOÁN "LỖI" (ERROR) - PHIÊN BẢN SỬA LỖI ---
  // Dựa trên logic switch-case của bạn
  // SENSOR_1, SENSOR_2 -> bên phải
  // SENSOR_3, SENSOR_4 -> bên trái

  // Gán trọng số: [-3, -1, 1, 3] cho các cảm biến [S4, S3, S2, S1]
  // Khi robot lệch trái, cảm biến 3, 4 sẽ thấy line -> lỗi âm
  // Khi robot lệch phải, cảm biến 1, 2 sẽ thấy line -> lỗi dương
  error = (b4 * -3) + (b3 * -1) + (b2 * 1) + (b1 * 3);

  // Xử lý trường hợp mất line (0000)
  if (!b1 && !b2 && !b3 && !b4) {
    if (lastError > 0) { // Lần cuối lệch phải
      error = 5; // Gán lỗi dương lớn để rẽ mạnh sang trái
    } else { // Lần cuối lệch trái
      error = -5; // Gán lỗi âm lớn để rẽ mạnh sang phải
    }
  }

  // --- TÍNH TOÁN PID ---
  long proportional = error;
  long derivative = error - lastError;
  // Bỏ qua integral lúc này
  // integral += error;

  // Giá trị điều chỉnh cuối cùng
  int correction = (Kp * proportional) + (Kd * derivative);

  // Cập nhật lỗi cuối cùng cho vòng lặp tiếp theo
  lastError = error;

  // --- TÍNH TOÁN TỐC ĐỘ ĐỘNG CƠ - PHIÊN BẢN SỬA LỖI ---
  // Đây là điểm mấu chốt:
  // Nếu lỗi DƯƠNG (lệch phải), robot cần RẼ PHẢI.
  // Để rẽ phải, bánh trái phải nhanh hơn, bánh phải chậm hơn.
  // Do đó, ta phải **TRỪ** `correction` khỏi tốc độ bánh phải và **CỘNG** vào bánh trái.
  // Hoặc đơn giản là đổi dấu của `correction`.
  // Cách thường dùng là:
  int leftSpeed = maxSpeed + correction;
  int rightSpeed = maxSpeed - correction;
  
  // Gửi tốc độ đến động cơ
  setMotorSpeeds(leftSpeed, rightSpeed);

  // In ra để debug và tinh chỉnh Kp, Ki, Kd
  Serial.print("S: "); Serial.print(b1); Serial.print(b2); Serial.print(b3); Serial.print(b4);
  Serial.print(" | Error: "); Serial.print(error);
  Serial.print(" | Corr: "); Serial.print(correction);
  Serial.print(" | L: "); Serial.print(leftSpeed);
  Serial.print(" | R: "); Serial.println(rightSpeed);
  
  delay(10);
}
